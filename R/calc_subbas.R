# lumpR/subbasin.R
# Copyright (C) 2014-2023 Tobias Pilz
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#' Calculation of hydrological subbasins using GRASS GIS
#' 
#' Takes DEM from a GRASS location and a file of drainage locations to calculate 
#' hydrological subbasins for each drainage point using GRASS functions.
#' 
#' @param dem Digital Elevation Model in GRASS location used for delineation of
#'      subbasins. Should be larger than the expected catchment, otherwise artefacts
#'      close to boundaries may occur.
#' @param drain_points \code{SpatialPoints} object containing drainage points (i.e. subbasin outlets) in
#'      units of and compliant with the projection of your respective GRASS location.
#'      Can, e.g., be imported from GRASS with
#'      \code{drain_points = read_VECT(vname = "subbas_outlets", layer=1)} \cr
#'      At least the overall basin drainage point has to be given. If \code{drain_points} contains a column
#'      \code{subbas_id} in the attribute table, its values will be used for numbering the subbasins.\cr
#'      IDs of additionally delineated subbasins (if \code{thresh_sub != NULL}) will be appended after the highest ID.
#' @param river River vector map in GRASS location if available - use only if this vector map is strictly consistent
#'      with the DEM in use. If set to \code{NULL}
#'      (default value), the river network will be calculated by GRASS function \emph{r.watershed}.
#' @param flowaccum (optional) Existing raster map of flow accumulation in GRASS location (saves computation time). Must correspond to a map generated by the GRASS function \code{r.watershed}.
#'      If \code{drainage_dir} or \code{flowaccum} is set to \code{NULL} (default value), both will be calculated with \emph{r.watershed}.
#' @param drainage_dir (optional) Existing raster map of drainage direction in GRASS location. Must correspond to map generated by the GRASS function \code{r.watershed}.
#'      If \code{drainage_dir} or \code{flowaccum} is set to \code{NULL} (default value), both will be calculated with \emph{r.watershed}.
#' @param disk_swap (optional) Only needed if memory requirements exceed available RAM (large DEMs): If set to \code{TRUE}, \code{r.watershed} uses the "-m"-flag (slow)
#' @param basin_out Output: Name of subbasins raster map exported into GRASS location.
#' @param stream Output: Prefix of calculated stream segments vector (<stream>_vect) and
#'      raster (<stream>_rast) maps exported into GRASS location. Only generated if
#'      \code{river} is not set. Default: \code{NULL}.
#' @param points_processed Output: Prefix of intermediate point vector files exported to GRASS location, if \code{keeptemp = TRUE}
#'      For details, see section "Value" below.
#' @param outlet Integer (row number) defining the catchment outlet in \code{drain_points}.
#'      If there are \code{drain_points} outside the watershed delineated for the
#'      outlet point these will be omitted. If \code{NULL} (default) and \code{drain_points}
#'      contains only one point this will be assumed as catchment outlet.
#' @param thresh_stream Integer defining threshold for stream calculation. Raster
#'      cells in accumulation map with values greater than thresh_stream are
#'      considered as streams. Needs to be set only if \code{river} is not set.
#'      Default: \code{NULL}.
#' @param thresh_sub Integer defining threshold for subbasin calculation. Parameter for
#'      GRASS function \emph{r.watershed} defining the minimum size of an exterior
#'      watershed basin in number of grid cells. If \code{NULL} (default) only the
#'      given drainage points are used for subbasin delineation.
#' @param snap_dist maximum distance (in map units) to use when the points in \code{drain_points} are corrected to the nearest stream segment ("snapping").
#'      Non-snappable drainage points will be excluded with a warning. Default: 300
#' @param rm_spurious \code{numeric}. If greater zero, spurious subbasins will
#'      be removed, i.e. those subbasins being smaller than \code{rm_spurious} times \code{thresh_sub}.
#'      Spurious subbasins are 'interior' watersheds created by GRASS function
#'      \emph{r.watershed} around stream segments below multiple tributaries. If they
#'      are very small they induce unnecessary computational burden when used within a
#'      hydrological model. If removed, these areas will be related to the next upstream
#'      subbasins, respectively. If \code{thresh_sub = NULL} (default) \code{rm_spurious}
#'      will be automatically set to \code{0}. Default: 0.01.
#' @param keep_temp \code{logical}. Set to \code{TRUE} if temporary files shall be kept
#'      in the GRASS location, e.g. for debugging or further analyses. Default: \code{FALSE}.
#' @param overwrite \code{logical}. Shall existing GRASS layers of previous calls of this function be
#'      overwritten? If \code{FALSE} the function returns an error if a layer already exists.
#'      Default: \code{FALSE}.
#' @param silent \code{logical}. Shall the function be silent (also suppressing warnings
#'      of internally used GRASS functions)? Default: \code{FALSE}.
#'      
#' @return Function returns nothing. Various output is generated in the GRASS-location:
#'  \itemize{
#'    \item{stream segments}{If \code{river} is not supplied,  vector (<stream>_vect) and raster (<stream>_rast) will be generated.} 
#'    \item{Subbasin map}{raster map \code{basin_out}} 
#'  }  
#'  If \code{keep_temp=TRUE}, the following temporary maps are preserved and can be used for tracing errors:
#'  \itemize{
#'    \item{\code{accum_t}:}{ If argument \code{flowaccum} is not supplied, contains map of flow accumulation.} 
#'    \item{\code{drain_t}:}{ If argument \code{drainage_dir} is not supplied, contains map of drainage direction.} 
#'    \item{\code{<points_processed>_t}:} { Prespecified subbasin outlet points.} 
#'    \item{\code{<points_processed>_snapped_t}:}{ Prespecified subbasin outlet points snapped to closest river.} 
#'    \item{\code{<points_processed>_calc_t}:}{ Automatically calculated subbasin outlet points (only if parameter \code{thresh_sub} is not NULL).} 
#'    \item{\code{<points_processed>_all_t}:}{ Combined subbasin outlet points (manual and automatically-computed ones) as raster (easier to identify double subbasin outlet points sharing one raster cell).} 
#'  }  
#'      
#' @details
#'  The function constructs subbasins. It can use user-specified outlet points \code{param drain_points}, and/or the area-threshold \code{param thresh_sub}.
#'  The user-specified outlet points are snapped to the nearest river location (to fix inaccuracies) and will result in mandatory subcathcments.
#'  The area-threshold serves for further delineation (if necessary), and potential merging of too-small subcatchments.

#' @note \bold{Prepare GRASS location}  and necessary raster files in advance and start
#'      GRASS session in R using \code{\link[rgrass]{initGRASS}}. The GRASS location
#'      should not contain any maps ending on *_t as these will be considered temporary maps and removed. 
#'      
#'      You should select your DEM \bold{sufficiently large}. Otherwise, the resulting
#'      catchment might be truncated or boundaries influence the calculation
#'      of stream segments.
#'      
#'      \bold{Check the results} (subbasins and snapped points). In case points have been snapped
#'      to the wrong stream segment, adjust point locations manually in GRASS and re-run
#'      the function with the updated locations (use \code{\link[rgrass]{read_VECT}}
#'      to import the updated drainage points).
#'      
#'      Generated raster and vector stream \bold{maps might slightly deviate} from each other
#'      as the raster map is thinned (GRASS function \emph{r.thin}) prior to conversion
#'      to a vector map to ensure strictly linear features.
#'      
#'      If you run into \bold{memory issues}, consider argument \code{disk_swap} (see also 
#'      \link[GRASS homepage]{https://grass.osgeo.org/grass74/manuals/r.watershed.html#in-memory-mode-and-disk-swap-mode})
#'      and see discussion on \link[lumpR's github page]{https://github.com/tpilz/lumpR/issues/16}.
#'      
#' @references 
#'      lumpR package introduction with literature study and sensitivity analysis:\cr
#'      Pilz, T.; Francke, T.; Bronstert, A. (2017): lumpR 2.0.0: an R package facilitating
#'      landscape discretisation for hillslope-based hydrological models.
#'      \emph{Geosci. Model Dev.}, 10, 3001-3023, doi: 10.5194/gmd-10-3001-2017
#' 
#' @author Tobias Pilz \email{tpilz@@uni-potsdam.de}, Till Francke

calc_subbas <- function(
  ### INPUT ###
  dem=NULL,
  drain_points=NULL,
  river=NULL,
  flowaccum=NULL,
  drainage_dir=NULL,
  disk_swap=FALSE,
  
  ### OUTPUT ###
  basin_out=NULL,
  stream=NULL,
  points_processed=NULL,
  
  ### PARAMETER ###
  outlet=NULL,
  thresh_stream=NULL,
  thresh_sub=NULL,
  snap_dist=300,
  rm_spurious=0.01,
  keep_temp=FALSE,
  overwrite=FALSE,
  silent=FALSE
) {
  
  ### PREPROCESSING ###----------------------------------------------------------
  
  if(!silent) message("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
  if(!silent) message("% START calc_subbas()")
  if(!silent) message("%")
  if(!silent) message("% Initialise function...")
  
  # CHECKS #
  tryCatch(gmeta(), error = function(e) stop("Cannot execute GRASS commands. Maybe you forgot to run initGRASS()?"))
  if(is.null(dem) | dem=="")
    stop("'dem' (name of a DEM within the mapset of your initialised GRASS session) has to be given!")
  if(is.null(drain_points) | !grepl("SpatialPoints", class(drain_points)))
    stop("'drain_points' has to be given as SpatialPoints* object with at least one catchment outlet point!")
  if(is.null(river) & (is.null(thresh_stream | is.null(stream))))
    stop("If 'river' is not specified, 'stream' as name prefix for the generated stream maps and 'thresh_stream' have to be specified for internal calculation of the river network!")
  if(!is.null(river))
    check_vector(river, "river")
  if (identical(flowaccum,"")) flowaccum=NULL
  if (identical(drainage_dir,"")) drainage_dir=NULL
  if(xor(!is.null(flowaccum), !is.null(drainage_dir))) 
    stop("If using existing rasters 'flowaccum' and 'drainage_dir', both have to be specified (or neither).")
  if(is.null(basin_out)  | basin_out=="")
    stop("You have to specify 'basin_out' as name for the subbasin map to be generated!")
  if(is.null(points_processed))
    stop("You have to specify points_processed!")
  outlet = as.integer(round(outlet))
  if(!is.null(outlet) & !is.integer(outlet))
    stop("'outlet' has to be an integer number!")
  if(!is.numeric(snap_dist))
    stop("You have to specify 'snap_dist' as a number!")
  if(is.null(outlet)) {
    if(nrow(drain_points@coords) > 1)
      stop("You have to give 'outlet' if there a more than one points in 'drain_points'!")
    outlet <- 1
  }
  if(is.null(thresh_sub))
    rm_spurious <- 0
  if(!is.numeric(rm_spurious))
    stop("Argument 'rm_spurious' has to be numeric (behaviour changed in version 2.0.4)!")
  
  
  # CLEAN UP AND RUNTIME OPTIONS #  
  GRASSver <- execGRASS("g.version", intern=TRUE)
  if (GRASSver=="")
    stop("Couldn't connect to GRASS-session. Try removing any open sinks by calling 'sink()' repeatedly. Or restart R.")
  ver_no = gsub(GRASSver, pattern="GRASS *([^\\.]).*", repl="\\1") #extract main grass version
  
  
  # suppress annoying GRASS outputs 
  tmp_file <- file(tempfile(), open="wt")
  sink(tmp_file, type="output")
  
  
  # also suppress warnings in silent mode
  if(silent){
    tmp_file2 <- file(tempfile(), open="wt")
    sink(tmp_file2, type="message")
    oldw <- getOption("warn")
    options(warn = -1)
  }
  
  cleanup = function() {
    #cleanup function in case of errors or normal termination 
    
    # stop sinking
    closeAllConnections()
    
    # restore original warning mode
    if(silent)
      options(warn = oldw)
    
    #if (geterrmessage()!= fake_error) #check if this is a real error having been raised
    #  print("real")
    
    # remove mask if there is any (and ignore error in case there is no mask)
    tt = try(execGRASS("r.mask", flags=c("r"), intern = TRUE, ignore.stderr = TRUE), silent = TRUE)
    
    #delete temporarily created maps
    if(keep_temp == FALSE)
      try(execGRASS("g.remove", type="raster,vector", pattern=paste0("*_t,",stream,"_*,", basin_out, ",", points_processed, "_*"), flags=c("f", "b"), intern = TRUE, ignore.stderr = TRUE), silent=TRUE)
    
    options(error=NULL) #release error handling
    
  }
  options(error=cleanup) #in case of errors, clean up and reset to original warning and messaging state
  
    
  ### CALCULATIONS ###-----------------------------------------------------------
 #tryCatch({
    
    # remove mask if there is any (and ignore error in case there is no mask)
   cmd_out= try(execGRASS("r.mask", flags=c("r","-quiet")), silent=TRUE)
    
    
    if (!is.null(drain_points))
    {  
    #check if given drainage points are within DEM extent
    cmd_out <- execGRASS("r.info", map=dem, flags=c("g"), intern=T)
    if (!is.null(attr(cmd_out, "status")) && attr(cmd_out, "status")!=0) stop("Specified DEM not found.")
    extent_dem = read.table(text=cmd_out, sep="=", nrows = 6)
    rownames(extent_dem) = extent_dem[,1]
      if (
        extent(drain_points)@xmin < extent_dem["west",2] |
        extent(drain_points)@xmax > extent_dem["east",2] |
        extent(drain_points)@ymin < extent_dem["south",2] |
        extent(drain_points)@ymax > extent_dem["north",2] 
      )  stop("Supplied drainage points do not seem to lie within the extent of the DEM. Please check.")
    }  
    
  
    # remove output of previous function calls if overwrite=T
    if (overwrite) {
      remove_pattern=paste0("*_t,", basin_out, ",", points_processed, "_*")

      keep_maps = NULL
      if (!is.null(river))
        keep_maps <- c(keep_maps, river) #keep rivermap if prespecified
      if (!is.null(flowaccum))
        keep_maps <- c(keep_maps, flowaccum) #keep flowaccum if prespecified
      if (!is.null(drainage_dir))
        keep_maps <- c(keep_maps, drainage_dir) #keep drainage_dir if prespecified
        
      cmd_out <- execGRASS("g.remove", type="raster,vector", pattern=remove_pattern, exclude=paste0(keep_maps, collapse=","),
                             flags=c("f", "b"), intern=TRUE)
    } 
    
    if(!is.null(flowaccum) )
    {
      # copy existing maps
      if (flowaccum != "accum_t")
        x <- execGRASS("g.copy", raster=paste0(flowaccum,",accum_t"), intern=TRUE, ignore.stderr = TRUE)
      if (drainage_dir != "drain_t")
        x <- execGRASS("g.copy", raster=paste0(drainage_dir,",drain_t"), intern=TRUE, ignore.stderr = TRUE)
    }
    
    if(!silent) message("% OK")
    
    
    ### calc stream segments or use user defined input---------------------------
    
    if(disk_swap) {
      ws_flags <- c("overwrite","m", "s")
    } else {
      ws_flags <- c("overwrite", "s")
    }
    
  
  # GRASS watershed calculation #
  # flags to use for r.watershed
  
  if(is.null(flowaccum) )
  {  
    if(!silent) message("%")
    if(!silent) message("% Calculate flowaccumulation and drainage direction...")
    execGRASS("r.watershed", elevation=dem, accumulation="accum_t", drainage="drain_t", flags = ws_flags)
    if(!silent) message("% OK")
  }
  # check flowaccum raster for negative values
  cmd_out <- execGRASS("r.univar", map="accum_t", separator="comma", flags=c("t"), intern=TRUE, ignore.stderr = TRUE) #ii: use "r.info -r" instead (faster)
  if (!is.null(attr(cmd_out, "status")) && attr(cmd_out, "status")!=0) stop(paste0("Could not get stats of ", flowaccum) )
  cmd_out <- strsplit(cmd_out, ",")
  if (!is.list(cmd_out)) stop("Error in computing stats of flow accumulation.")
  cmd_cols <- grep("^min$", cmd_out[[1]])
  min_acc <- as.numeric(cmd_out[[2]][cmd_cols])
  if(!is.finite(min_acc)) stop("Could not read stats of flow accumlation grid. Please check region setting with g.region() in GRASS.")
  
  if(min_acc < 0) warning("Negative flow accumulation values detected! This happens if cells get runoff from regions outside the study area, i.e. the extent of your DEM might be too small. Check if this could be a problem!")
  

  if(is.null(river)) {
    if(!silent) message("%")
    if(!silent) message("% Calculate river network...")
      cmd_cols <- grep("^max$|^min$", cmd_out[[1]]) # ignore negative accumulation values (warning will be issued)
      max_acc <- max(abs(as.numeric(cmd_out[[2]][cmd_cols])))
      if(thresh_stream > max_acc)
        stop(paste0("Parameter 'thresh_stream' (", thresh_stream, ") is larger than the maximum flow accumulation within the study area (", max_acc, "). Choose a smaller parameter value!"))
      # calculate stream segments (don't use output of r.watershed as streams should be finer than generated therein)
      cmd_out <- execGRASS("r.mapcalc", expression=paste0(stream, "_rast = if(abs(accum_t)>", format(thresh_stream, scientific = F), ",1,null())"), flags="overwrite", intern=T)
      # thin
      cmd_out <- execGRASS("r.thin", input=paste0(stream, "_rast"), output=paste0(stream, "_thin_t"), iterations=10000, flags=c("quiet", "overwrite"), intern=T)
      # convert to vector
      cmd_out <- execGRASS("r.to.vect", input=paste0(stream, "_thin_t"), output=paste0(stream, "_vect"), type="line", flags=c("quiet", "overwrite"), intern=T)
      river <- paste0(stream, "_vect")
      if(!silent) message("% OK")
      
    } 

    ### calculate subbasins without given drainage points (optional)-------------
    if(is.numeric(thresh_sub)) {
      if(!silent) message("%")
      if(!silent) message("% Calculate subbasins based on given area threshold...")
      
      # calculate subbasins
      cmd_out <- execGRASS("r.watershed", elevation=dem, basin="basin_calc_t", threshold=thresh_sub, flags = ws_flags, intern=T)
      if(!silent) message("% OK")
    }
    
    
    ### snap given drainage points to streams------------------------------------
    if(!silent) message("%")
    if(!silent) message("% Snap given drainage points to streams...")
    
    # add data slot and columns subbas_id and cat, if not given
    if(!any(slotNames(drain_points) == "data"))
      drain_points <- SpatialPointsDataFrame(drain_points, data=data.frame(subbas_id=1:length(drain_points)))
    
    if (any(duplicated(drain_points@data$subbas_id))) 
    {  
      warning("Duplicated subbas_id in drainage points. Ignoring IDs, using row numbers instead.")
      drain_points@data$subbas_id=NULL 
    }
    
    if(!any(colnames(drain_points@data) == "subbas_id"))
      drain_points@data <- cbind(drain_points@data, subbas_id=1:length(drain_points))
    if(!any(colnames(drain_points@data) == "cat"))
      drain_points@data <- cbind(drain_points@data, cat=1:length(drain_points))
    # force conversion to numeric 
    drain_points@data$subbas_id=as.numeric(as.character(drain_points@data$subbas_id)) 
    if (any(!is.finite(drain_points$subbas_id)))
      stop("The column 'subbasin_id' in drain_points contains non-numeric entries.")
    # write to GRASS
    suppressWarnings(proj4string(drain_points) <- CRS(getLocationProj()))
    suppressWarnings(write_VECT(vect(drain_points), paste0(points_processed,"_t"), flags = "overwrite"))

    clean_temp_dir(paste0(points_processed, "_t"))
    
    #alternative snapping (done in R. Very slow for some export/conversion steps, rasterization of stream vector is not thin - ambiguous snapping!)
    # # read stream vector
    # streams_vect <- read_VECT(river)
    # streams_vect = as(streams_vect, 'Spatial')
    # clean_temp_dir(river)
    # 
    # #buffer drainage points by supplied snapping distance
    # library(sf)
    # drain_points_buffered = st_buffer(as(drain_points, "sf"), dist=snap_dist) #create buffer around specified drainage points
    # 
    # #clip stream(line) with buffer
    # options(warn=-1) #disable warnings so we can convert to numeric without complaints 
    # river_clipped = st_intersection(sf::st_as_sf(streams_vect), drain_points_buffered)
    # 
    # # ss = 2
    # # plot(drain_points[ss, "cat"])
    # # plot(as(drain_points_buffered[ss, "cat"], "Spatial"), add=FALSE)
    # # plot(as(river_clipped[, "cat"], "Spatial"), add=TRUE)
    # 
    # #convert clipped stream to raster
    # 
    # #create raster template
    # cmd_out = execGRASS("r.info", map=flowaccum, flag=c("g"), intern = TRUE)
    # cmd_out_list = sapply(X=cmd_out, FUN=function(x){as.numeric(strsplit(x, split="=")[[1]][2])})  #split, convert to list
    # options(warn=0)
    # names(cmd_out_list)  = gsub(names(cmd_out_list), pattern="=.*", repl="") #fix list names
    # 
    # raster_template <- raster(nrows=cmd_out_list["rows"], ncols=cmd_out_list["cols"], xmn=cmd_out_list["west"], 
    #                           xmx=cmd_out_list["east"], ymn=cmd_out_list["south"], ymx=cmd_out_list["north"], 
    #                           crs=crs(drain_points), resolution=c(cmd_out_list["ewres"], cmd_out_list["nsres"])) #create template raster
    # 
    # river_clipped_rast = rasterize(x = as(river_clipped, "Spatial"), y = raster_template, field="subbas_id") #convert streams to raster
    # tt = as(river_clipped_rast, "SpatialGridDataFrame")
    # write_RAST (x=tt, vname="river_rast")
    # plot(river_clipped_rast, add=TRUE)
    # rm(raster_template) #no longer needed
    # 
    # #convert raster to points
    # streams_points = rasterToPoints(river_clipped_rast, spatial = TRUE)
    # streams_points = as(streams_points, "sf")
    # #plot(streams_points[streams_points$layer==31,])
    
    
    #done in GRASS...
    #buffer drainage points by supplied snapping distance
    cmd_out = execGRASS("v.buffer", input=paste0(points_processed,"_t"), output=paste0(points_processed,"_buffered_t"), distance=snap_dist, 
                        flags="overwrite", intern = TRUE)
    
    #clip raster stream with buffer
    cmd_out = execGRASS("g.rename", raster="MASK,MASK_bak", flags="overwrite", intern = TRUE) #save existing mask
    
    cmd_out = execGRASS("r.mask", vector=paste0(points_processed,"_buffered_t"), flags="overwrite", intern = TRUE) #create MASK from buffer
    cmd_out = execGRASS("r.mapcalc", expression=paste0(stream,"_clipped_t=", stream, "_thin_t"), flags="overwrite", intern = TRUE)

    cmd_out = execGRASS("g.remove", type="raster", name="MASK", flag="f", intern = TRUE) #remove MASK
    cmd_out = execGRASS("g.rename", raster="MASK_bak,MASK", flags="overwrite", intern = TRUE) #restore MASK
    
    
    #convert raster to points
    cmd_out = execGRASS("r.to.vect", input=paste0(stream,"_clipped_t"),
                                    output=paste0(stream,"_clipped_vec_t"), type="point", column="subbas_id",
                        flags=c("overwrite"), intern = TRUE) #convert clipped raster to points
    
    library(sf)
    streams_points <- read_VECT(paste0(stream,"_clipped_vec_t"))
    #streams_points = as(streams_points, 'Spatial') #we need this intermediate step, as direct conversion fails
    #streams_points = as(streams_points, 'sf')
    streams_points = st_as_sf(streams_points) #convert to sf
    clean_temp_dir(paste0(stream,"_clipped_vec_t"))
    
    #find nearest river point for each drainage point
    drain_points_sf = as(drain_points, "sf")
    ptdist <- st_distance(x=drain_points_sf, y=streams_points)
    min_ix   = apply(ptdist, MARGIN = 1, FUN = which.min) #find index of minimum for each drainage point
    min_dist = apply(ptdist, MARGIN = 1, FUN = min)       #extract minimum distance to stream network
    beyond_snapping_dist = which(min_dist > snap_dist)    #find drainage points that only found stream beyond snapping distance
    
    drain_points_snap = streams_points[min_ix,]
    #drain_points_snap$cat   = NULL 
    drain_points_snap$label = NULL #delete obsolete columns
    drain_points_snap$subbas_id = drain_points$subbas_id #correct subbas_id, which strangely is not correctly transferred during r.to.vect
    if (length(beyond_snapping_dist) > 0) #discard drainage points that could not be snapped
      drain_points_snap = drain_points_snap[-beyond_snapping_dist ,]

    # export drain_points_snap to GRASS
    suppressWarnings(write_VECT(vect(drain_points_snap), paste0(points_processed, "_snapped_t"), flags = "overwrite"))
    #drain_points_snap = read_VECT(paste0(points_processed, "_snapped_t")) #re-omit, for debugging only
    clean_temp_dir(paste0(points_processed, "_snapped_t"))
    
    if (nrow(drain_points_snap) < nrow(drain_points)) {
      if(!silent) message(paste0("The following outlet points are more than ", snap_dist," away from the stream and will be ignored. Fix their location manually or increase 'snap_dist' or 'thresh_stream' (creates a finer river network): ",
                                 paste0(drain_points_sf$subbas_id[beyond_snapping_dist], collapse=", ")))
    }else
      if(!silent) message("% OK") 
    
    
    ### calculate catchments for every drainage point----------------------------
    if(!silent) message("%")
    if(!silent) message("% Calculate catchments for every drainage point...")
    
    #compute entire catchment
    outlet <- which(drain_points_snap$subbas_id == outlet_id) # update index to outlet, as its order may have changed during previous steps
    drain_points_snap = as(drain_points_snap, "Spatial")
    outlet_coords <- coordinates(drain_points_snap)[outlet,]
    
    if(!silent) message("%  ...for outlet point...")
    cmd_out <- execGRASS("r.water.outlet", input="drain_t", output=paste0("basin_outlet_t"), coordinates=outlet_coords, flags="overwrite", intern = T)
    cmd_out = execGRASS("r.stats", input=paste0("basin_outlet_t"), flag=c("c","n","quiet"), intern = TRUE)
    if (length(cmd_out)==0)
      stop("Could not get stats of 'basin_outlet_t' (entire basin). Please check it and set GRASS region as 'g.region raster=basin_outlet_t'")
    ncells = as.numeric(strsplit(cmd_out, split = " ")[[1]][2])
    if (!is.finite(ncells) | ncells < 100)
      stop(paste0("Number of cells in calculated catchment is very low (",ncells,"). Try using a filled DEM or correcting this point."))
    
    # get drainage points of calculated subbasins (optional)
    if(is.numeric(thresh_sub)) {
      # the following calculations only make sense if thresh_sub is small enough to produce more subbasins than determined by drain_points
      #no_catch_calc <- length(as.numeric(execGRASS("r.stats", input="basin_calc_t", flags=c("n"), intern=T, ignore.stderr = T)))
      if(!silent) message("%  ...extracting outlet points of threshold-based subbasins...")
      cmd_out <- execGRASS("r.univar", map="accum_t", zones="basin_calc_t", separator="comma", flags=c("t", "g"), intern=TRUE, ignore.stderr = TRUE) 
      
      if ((!is.null(attr(cmd_out, "status")) && attr(cmd_out, "status")!=0))
        stop(paste0("Could not get zonal stats of 'accum_t' (flow accumulation) and 'basin_calc_t' (automatically calculated subcatchments). Check both rasters."))
      
      subbas_stats = read.table(text=cmd_out, sep=",", header=TRUE) #convert command output to dataframe
      no_catch_calc = nrow(subbas_stats)
      
      if(no_catch_calc > 1) {
        # identify automatically-generated outlet points and merge to pre-specified ones
        
        #assemble expression for identifying the outlet cells
        expr = paste0(paste0("(basin_calc_t==", subbas_stats$zone, " && abs(accum_t)==",subbas_stats$max,")"), collapse =" || ")
        
        #generate map designating output cells
        cmd_out2 <- execGRASS("r.mapcalc", expression=paste0("drain_points_calc_t=", expr), flags=c("overwrite"), intern=TRUE, ignore.stderr = FALSE)
        
        if (length(cmd_out2) > 0)
          stop("Could not detect threshold-based outlet points. Threshold too small, too many subbasins? Check raster map 'basin_calc_t' and report number of subbasins to developer.")
        
        #intersect identified points with subbasin map to get their IDs
        cmd_out2 <- execGRASS("r.mapcalc", expression="drain_points_calc2_t=if(drain_points_calc_t,basin_calc_t,null())", flags=c("overwrite"), intern=TRUE, ignore.stderr = FALSE)
        
        
        # #alternative: loop though all subbasins and find their outlet points 
        # #(slower by factor 2, but possibly necessary if the expression becomes too long? Although docu claims "There is no limit to the possible number of input lines or to the length of a formula."
        # cmd_out2 <- execGRASS("r.mapcalc", expression="drain_points_calc_t3=null()", flags=c("overwrite"), intern=TRUE, ignore.stderr = FALSE)
        # for (i in 1:nrow(subbas_stats))
        # {
        #   cmd_out2 <- execGRASS("r.mapcalc", expression=paste0("drain_points_calc_t3=if(basin_calc_t==",subbas_stats$zone[i], " && abs(accum_t)==",subbas_stats$max[i],",basin_calc_t,null())"), flags=c("overwrite"), intern=TRUE, ignore.stderr = FALSE)
        # } 
        
        #convert raster points to vector
        cmd_out <- execGRASS("r.to.vect", input="drain_points_calc2_t", output=paste0(points_processed, "_calc_vec_t"), type="point", flags=c("quiet", "overwrite"), intern=T)
        
        drain_points_calc <- read_VECT(paste0(points_processed, "_calc_vec_t")) #re-import to R
        drain_points_calc = st_as_sf(drain_points_calc) #convert to sf
        clean_temp_dir(paste0(points_processed, "_calc_vec_t"))
        
        #drain_points_snap = read_VECT(paste0(points_processed, "_snapped_t")) #re-import, for debugging only
        #drain_points_snap = as(drain_points_snap, "Spatial")
        
        # create consistent subbas_ids before merging prespecified and automatic drainage points
        new_ids = 1:(nrow(drain_points_calc) + nrow(drain_points_snap@data)) # potential new IDs for the automatically-identified basins
        new_ids = setdiff(new_ids, drain_points_snap@data$subbas_id) #remove IDs that are already in use from pre-specified points
        new_ids = new_ids[1:nrow(drain_points_calc)]  #use only as many as needed for the automatically-generated ones
        drain_points_calc$subbas_id = new_ids #set new IDs
        
        # write to GRASS location
        write_VECT(vect(drain_points_calc), paste0(points_processed, "_calc_vec_t"), ignore.stderr = T, flags = "overwrite")
        
        # set the same attributes to drain_points_snap and drain_points_calc_t to allow merging
        drain_points_snap@data <- drain_points_snap@data[,c("cat", "subbas_id")]
        suppressWarnings(proj4string(drain_points_snap) <- CRS(getLocationProj()))
        drain_points_calc = drain_points_calc[, c("cat", "subbas_id")]
        
        # merge with pre-specified drainage points object (pre-specified points first as there the outlet is identified)
        drain_points_snap <- rbind(drain_points_snap, as(drain_points_calc, "Spatial"))
      } # more than one subbasin

    }
    
    # combine drain points as raster (easier to identify double drain points sharing one raster cell)
    suppressWarnings(write_VECT(vect(drain_points_snap), paste0(points_processed, "_all_t"), flags = "overwrite"))
    clean_temp_dir(paste0(points_processed,"_all_t"))
    
    x <- execGRASS("v.to.rast", input=paste0(points_processed, "_all_t"), output=paste0(points_processed, "_all_t_t"), use="attr", attribute_column="subbas_id", flags="overwrite", intern=T)
    #? how do we ensure duplicate drainage points keep the manually assigned subbas_id? i.e., not being overwritten by automatically generated ID.
    x <- execGRASS("r.mapcalc", expression=paste0(points_processed, "_all_t=round(", points_processed, "_all_t_t)"), flags = c("overwrite"), intern=T) #convert raster map to integer
    x <- execGRASS("g.remove", type="raster", pattern=paste0(points_processed, "_all_t_t"), flags="f", intern=T) #remove temporary map required in previous line
    
    # get coordinates of drain point cells
    drainp_coords <- execGRASS("r.stats", input = paste0(points_processed, "_all_t"), flags=c("n", "g", "quiet"), intern=T)
    drainp_coords <- matrix(as.numeric(unlist(strsplit(drainp_coords, " "))), ncol = 3, byrow = T)
    
    #faster, but digits differ:
    # tt2 <- read_VECT(vname = paste0(points_processed,"_all_t"), layer=1)
    # tt3 = geom(tt2)[, c("x", "y", "geom")]
     
    
    # loop over drainage points of subbasins; TODO: This step is slow!
    for (p in 1:nrow(drainp_coords)) {
      if(!silent) message(paste0("% subbasin ",p, " of ", nrow(drainp_coords))) #progress indicator
      # outlet coordinates
      outlet_coords <- drainp_coords[p,c(1,2)]
      
      # drain points subbasin id (optionally defined in 'drain_points' input)
      id <- drainp_coords[p,3]
      
      # basin
      cmd_out <- execGRASS("r.water.outlet", input="drain_t", output=paste0("basin_", id, "_t"), coordinates=outlet_coords, intern = T)
      # TODO: better clip any already existing subbasins from the automatically generated map
      
      cmd_out = execGRASS("r.stats", input=paste0("basin_", id, "_t"), flag=c("c","n","quiet"), intern = TRUE)
      ncells = as.numeric(strsplit(cmd_out, split = " ")[[1]][2])
      if (!is.finite(ncells) | ncells < 100)
        warning(paste0("Number of cells in calculated catchment ",id," is very low (",ncells,"). Try using a filled DEM and check outlet points."))
      
      # reclass (for crossing later on)
      # ii: can this be done with reclass to conserve space?
      cmd_out <- execGRASS("r.mapcalc", expression=paste0("basin_recl_", id, "_t = if(basin_", id, "_t,", id, ")"), intern=T)
      
    }
    
    no_catch <- nrow(drainp_coords) #current number of subcatchments
    
    if(!silent) message(paste("% -> Identified", no_catch, "subbasins."))
    if(!silent) message("% OK")
    
    
    
    ### merge all sub-catchments-------------------------------------------------
    # the computed catchments are still overlapping (nested), some may be smaller than desired. This is remedied in the next steps:
    if(!silent) message("%")
    if(!silent) message("% Merge calculated catchments...")
    #browser()
    # put sub-catchments together
    subcatch_rasts <- paste0("basin_recl_",drainp_coords[,3], "_t")
    
    iteration_nr= 0 #initialise counting variable; number of iterations needed to remove spurious subbas
    sub_sizes_int_prev=NULL #for recording any changes between iterations
    
    # if more than one sub-catchment
    if(no_catch > 1) {
      
      # iterate until configuration without 'spurious' sub-catchments is found (if rm_spurious > 0) TODO: This step is slow in case many iterations are needed!
      while (TRUE) {
        
        if(iteration_nr > 10)
        {
          if(!silent) message("% Could not resolve all spurious subcatchments, iteration limit exceeded. Check results manually.")
          break # exit while loop
        }
        
        if(!silent) message(" ...merging subbasins...")
        
        # derive overlap/neighbourhood information of identified subbasins
        # max 30 maps at once, create multiple cross products if necessary
        x <- execGRASS("g.remove", type="raster", pattern="basin_cross_*", flags="f", intern=T) # remove old basin_cross_*
        iterations <- ceiling(length(subcatch_rasts)/30) # "r.cross" can only handle up to 30 layers, so we may have to make several iterations
        for (j in 1:iterations){
          if (j == iterations) {
            if(length(subcatch_rasts) %% 30 == 1) { #special case: only one subbasin remaining
              x <- execGRASS("g.copy", raster=paste(subcatch_rasts[((j-1)*30+1):length(subcatch_rasts)], paste0("basin_cross_", j, "_t"), sep=","), 
                             intern=T, ignore.stderr=T)
            } else { #general case: more than one remaining
              x <- execGRASS("r.cross", input=paste(subcatch_rasts[((j-1)*30+1):length(subcatch_rasts)], collapse=","),
                             output=paste0("basin_cross_", j, "_t"), flags = c("overwrite"), intern=T, ignore.stderr=T)
            }
          } else {
            x <- execGRASS("r.cross", input=paste(subcatch_rasts[((j-1)*30+1):(j*30)], collapse=","),
                           output=paste0("basin_cross_", j, "_t"), flags = c("overwrite"), intern=T, ignore.stderr=T)
          }
        }
        
        cross_rasts <- execGRASS("g.list", type="raster", pattern=paste0("basin_cross_[0-9]*_t"), intern=T) #get names of resulting rasters
        
        if(length(cross_rasts) == 1) 
        { #only single iteration, just rename
          x <- execGRASS("g.rename", raster=paste(cross_rasts, "basin_all_t", sep=","), intern=T, ignore.stderr=T)
        } else 
        { # merge cross products of the multiple iterations of blocks of 30
          x <- execGRASS("r.cross", input=paste(cross_rasts,collapse=","), output="basin_all_t",
                         flags = c("overwrite"), intern=T, ignore.stderr=T)
        }
        # --> results available in raster "basin_all_t"
        
        
        #Aim: keep manually specified outlets, even if produced subbas < rm_spurious
        #     if specified subbas too small, remove upstream neighbours instead and merge with specified subbas
        
        
        #find out subbas combinations / upstream subbas, and their area (in cells)
        cmd_out <- execGRASS("r.stats", input="basin_all_t", flags=c("n","l", "c"), intern=T, ignore.stderr = T)
        #reformat list data
        # cmd_out=  gsub(x=cmd_out, pattern = "^(\\d*) ", repl="\\1;") # separate 1st ID in line with ;
        # cmd_out = gsub(x=cmd_out, pattern = "category", repl="")     # remove "category"
        # cmd_out = gsub(x=cmd_out, pattern = " *", repl="")           # remove blank space
        # cmd_out = gsub(x=cmd_out, pattern = "NULL", repl="")         # remove "NULL"
        # cmd_out = strsplit(cmd_out, split = ";")                     # split entries
        # cmd_out = lapply(FUN=as.numeric, cmd_out)
        
        cmd_out = gsub(x=cmd_out, pattern = "category | *NULL", repl="")     # remove "category " and "NULL"
        cmd_out = strsplit(cmd_out, split = ";| ")                     # split entries
        cmd_out = lapply(FUN=as.numeric, cmd_out) #convert to numbers
        
        
        #get maximum subbas_id in entire list
        #max_subbas_id = max(as.numeric(sapply(FUN=max, cmd_out, na.rm=TRUE))) #number of columns
        
        #n_comb = max(sapply(FUN=length, cmd_out))  #get number of columns to produce
        #subbas_combinations = array(NA, c(length(cmd_out), n_comb))
        
        #create array of subbas combinations, indicating if and which subbasins (still) overlap
        #subbas_combinations = array(NA, c(length(cmd_out), max_subbas_id)) #array with n_lines = length(cmd_out) and n_cols = max_subbas_id
        cross_ids    = array(NA, length(cmd_out)) #subbasin IDs in combination map of r.cross
        sub_sizes_int = array(NA, length(cmd_out)) #subbasin size in combination map (in cells)
        subbas_combinations_ix = list() #external IDs of downstream subbasins for each subbasin
        for(i in 1:length(cmd_out))
        {
          col_indices=as.numeric(cmd_out[[i]])
          cross_ids   [i] = col_indices [1] #extract internal subbas ID
          sub_sizes_int[i] = col_indices [length(col_indices)] #extract subasin size
          
          subbas_combinations_ix[[i]] =  na.omit(cmd_out[[i]][-c(1, length(col_indices))]) #save the external IDs of all subbasins overlapping with the current one
          #subbas_combinations[i, na.omit(col_indices [-1])] = TRUE
        }
        #subbas_combinations[is.na(subbas_combinations)] = FALSE #replace NAs with FALSE
        
        # check size of sub-catchments and identify and remove 'spurious' sub-catchments
        if(rm_spurious>0) {
          if(!silent) message(paste("% Iteratively remove spurious subcatchments ...(Iteration:",iteration_nr,")"))
          iteration_nr = iteration_nr+1
          # get sub-catchments and sizes (cell counts) and identify spurious ones
          #cmd_out <- execGRASS("r.stats", input="basin_all_t", flags=c("n", "c"), intern=T, ignore.stderr = T) #get internal subbas IDs of basin_all_t, and cell counts
          #sub_sizes_int <- matrix(as.numeric(unlist(strsplit(cmd_out, " "))), ncol=2, byrow=T) #subbasin sizes in cell counts
          
          sub_rm_int <- cross_ids[which(sub_sizes_int < rm_spurious*thresh_sub)] #internal subbas IDs which are below removal threshold
          
          #check if there have been any changes since the last iteration
          if (!is.null(sub_sizes_int_prev) & identical(sub_sizes_int_prev, sub_sizes_int))
          { #no changes
            if(!silent) message("% Could not resolve some subcatchments below threshold (", paste0(sub_rm_int, collapse=", "),"). Refine manually, if required.")
            break # exit while loop
          } else
          { #something changed, keep going
            sub_sizes_int_prev = sub_sizes_int #save for comparison in next iteration
          }
          
          if(length(sub_rm_int)>0) {
            # get external IDs in basin_recl_* to be removed (not identical with internal raster values of basin_all_t!)
            #cmd_out <- execGRASS("r.univar", map=paste0(points_processed, "_all_t"), zones="basin_all_t", separator="comma", flags=c("t"), intern=T, ignore.stderr = T)
            #ii: could this be combined with the prior call?
            cmd_out <- execGRASS("r.stats", input=paste0("basin_all_t,", points_processed, "_all_t"), flags=c("n"), separator="comma", intern=T, ignore.stderr = T)
            cmd_out <- strsplit(cmd_out, ",") #conversion table internal "ID of r.cross" to external "ID of subbasins" 
            
            # convert output to matrix; this is the translation of internal temp. subbas IDs (1st column) to external drain point subbas IDs (2nd column)
            basins_points = matrix(as.numeric(unlist(cmd_out)), ncol=2, byrow = TRUE, dimnames = list(NULL, c("intern", "extern")))
            
            # get external subbas IDs to be removed
            sub_rm_ext <- basins_points[which(basins_points[,"intern"] %in% sub_rm_int), "extern"]
            #browser()
            
            manual_subs_ext       = drain_points@data$subbas_id #these points are manually specified outlets (=external IDs) 
            manual_subs_int       = basins_points[basins_points[, "extern"] %in% manual_subs_ext, "intern"] 
            manual_subs_ext_2small = intersect(sub_rm_ext, manual_subs_ext) #manually specified outlets (=external IDs), which are too small, but should not be removed
            
            remove_instead_int = NULL
            if (length(manual_subs_ext_2small)>0) #if manually specified external subbas ID detected as "too small", remove their upstream neighbours instead and merge to too-small basin 
            {
              for (cur_sub_ext in manual_subs_ext_2small) #cur_sub_ext = external ID
              {
                cur_sub_int = basins_points[basins_points[,"extern"] == cur_sub_ext, 1]   #cur_sub_int = internal ID in temporary basin map
                #curr_line = subbas_combinations[ as.numeric(cur_sub_int),] #configuration of current subbasin
                #curr_line = na.omit(as.numeric(cmd_out[[ cur_sub_int ]][-1])) #configuration of current subbasin
                
                curr_line = subbas_combinations_ix[[ which(cur_sub_int == cross_ids) ]] #configuration of current subbasin, contains internal subbas IDs of all encompassing higher hierarchy basins
                
                #detect nested and nesting catchments by comparing to current configuration
                #tt =apply(subbas_combinations, MARGIN = 1, FUN= function(x,y){sum(x!=y)}, y=curr_line)
                #tt =unlist(lapply(subbas_combinations_ix, FUN= function(x,y){length(c (setdiff(x, y), setdiff(y,x)) )}, y=curr_line)) 
                #number of differences in configuration; 0 = currently active subbas; 1 = direct upstream or downstream neighbour
                # upstream_neighbours_int =  cross_ids[which(tt == 1)] #internal subbas ID of upstream neighbours
                # for (j in upstream_neighbours_int)   # remove first downstream internal subbas ID (only preserve upstream neighbours)
                # {
                #   
                #   if (!cur_sub_ext %in% subbas_combinations_ix[[which(cross_ids ==j)]]) #test, if found neighbour has current subbas as downstream
                #     upstream_neighbours_int = setdiff(upstream_neighbours_int, j)
                # }
                
                #find ds neighbour
                #tt = unlist(lapply(subbas_combinations_ix, FUN= function(ds, us){length(setdiff(ds, us)) ==0 && length(setdiff(us,ds)) ==1}, us = curr_line)) 
                #find us neighbour
                tt = unlist(lapply(subbas_combinations_ix, FUN= function(ds, us){length(setdiff(ds, us)) ==0 && length(setdiff(us,ds)) ==1}, ds = curr_line)) 
                
                upstream_neighbours_int =  cross_ids[which(tt == 1)] #internal subbas ID of upstream neighbours. Use only the 
                upstream_neighbours_int =  setdiff(upstream_neighbours_int, manual_subs_int) #exclude subbas, that also have been manually specified, from removing
                if (length(upstream_neighbours_int) > 0) #found any? mark for removing
                  remove_instead_int = c(remove_instead_int, upstream_neighbours_int[1]) #internal ID of upstream  subbas to be removed
                
              }
              #browser()
              
              sub_rm_ext = setdiff(sub_rm_ext, manual_subs_ext_2small) #(external ID); dpreserve the manually specified ones from removal
              # translate internal ID of subbas to remove into external ID 
              remove_instead_ext = basins_points[basins_points[, "intern"] %in% remove_instead_int, "extern"]
              sub_rm_ext = unique(c(sub_rm_ext, remove_instead_ext)) #external ID; instead, use their upstream neighbours
            }  
            
            # remove this temporary map from processing and drain points raster map and try again (back to start of while loop)
            #browser()
            
            subcatch_rasts <- grep(paste0("basin_recl_", sub_rm_ext, "_t", collapse="|"), subcatch_rasts, invert = T, value = T)
            x <- execGRASS("g.remove", type="raster", name="basin_all_t", flags = "f", intern=T)
            tmp_file <- tempfile()
            stats_t <- as.integer(execGRASS("r.stats", input = paste0(points_processed, "_all_t"), flags=c("n", "quiet"), intern=T)) #get external drain point subbas IDs
            stats_t <- stats_t[!(stats_t %in% sub_rm_ext)]  #!!without IDs to be removed
            write(paste(paste(sub_rm_ext, "NULL", sep = " = ", collapse = "\n"), paste(stats_t, stats_t, sep=" = ", collapse = "\n"), sep="\n"), file=tmp_file)
            x <- execGRASS("r.reclass", input=paste0(points_processed, "_all_t"), output=paste0(points_processed, "_all2_t"),
                           rules = tmp_file, flags = "overwrite")
            x <- execGRASS("r.mapcalc", expression=paste0(points_processed, "_all_t=", points_processed, "_all2_t"), flags="overwrite", intern=T) # convert to regular map
            # update no_catch
            no_catch <- no_catch - length(sub_rm_ext)
          } else {
            break
          }
        } else {
          break # exit while loop
        }
        
      } # end while-loop
      
      # constrain to catchment of outlet point
      cmd_out <- execGRASS("r.mapcalc", expression=paste0(basin_out, "_t = basin_outlet_t * basin_all_t"), intern=T, flags="overwrite")
      
      
    } else 
    { # only one sub-catchment
      
      cmd_out <- execGRASS("g.copy", raster=paste0("basin_outlet_t,", basin_out, "_t"), intern=T)
      
      if(no_catch == 0)
        stop("Number of identified sub-catchments is zero. Check input data!")
    }
    
    # assign correct ids (from 'subbas_id') to basin_out
    cmd_out <- execGRASS("r.to.vect", input = paste0(points_processed, "_all_t"), output = paste0(points_processed, "_all_t"),
                         type = "point", column = "subbas_id", flags = c("overwrite", "quiet"), intern=T)
    cmd_out <- execGRASS("v.db.addcolumn", map=paste0(points_processed, "_all_t"), columns="temp_id int", intern=TRUE) 
    cmd_out <- execGRASS("v.what.rast", raster=paste0(basin_out, "_t"), map=paste0(points_processed, "_all_t"), column="temp_id" ,intern=T, ignore.stderr = T)
    drain_points_snap <- read_VECT(paste0(points_processed, "_all_t"))
    drain_points_snap = as(drain_points_snap, 'Spatial')
    nas = which(is.na(drain_points_snap@data$temp_id))
    if (any(nas))
    {  
      warning("Drainage point(s) ", paste0(nas, collapse=", "), " seem to lie outside catchment, please check.")
      drain_points_snap@data = drain_points_snap@data[-nas,]
    }  
    dat_rules <- paste(drain_points_snap@data$temp_id, "=", drain_points_snap@data$subbas_id, collapse = "\n") 
    tmp_file <- tempfile()
    write(dat_rules, file=tmp_file) # GRASS Gis reclass file: Old_ID = New_ID, temp_id is changed to subbas_id
    cmd_out <- execGRASS("r.reclass", input = paste0(basin_out, "_t"), output = paste0(basin_out, "2_t"), rules = tmp_file)
    cmd_out <- execGRASS("r.mapcalc", expression = paste0(basin_out, "=", basin_out, "2_t"), intern = T)
    
    no_cross <- length(execGRASS("r.stats", input=basin_out, flags=c("n"), intern=T, ignore.stderr = T))
    if(no_catch != no_cross) warning(paste0("\nNumber of categories in ", basin_out, " not equal to number of drainage points!\nThis might be because there are drainage points outside the catchment of the defined outlet or due to small inconsistencies between calculated and manually defined (and snapped) drainage points. However, you should check the output with the GRASS GUI and consider the help pages of this function. 
                                            Try correcting the drainage points manually by running 'v.digit map=drain_points_snap bgcmd=d.rast stream_accum_rast'"))
    
    
    
    # remove temporary maps
    if(keep_temp == FALSE)
      execGRASS("g.remove", type="raster,vector", pattern="*_t", flags=c("f"))
    
    
    if(!silent & rm_spurious > 0) message(paste("% -> Checked for spurious subbasins; ", no_catch, "subbasins left."))
    if(!silent) message("% OK")
    if(!silent) message("%")
    if(!silent) message("% -> Check the results for plausibility (e.g. inaccuracies at snapping of drain_points to streams may occur).")
    if(!silent) message("% -> If manual adjustments are necessary re-run this function. Existing grids of flow accumulation and direction may be used for speed-up.")
    if(!silent) message("% -> Note: Subbasin IDs of the calculated map 'subbas' might not be consecutively numbered! Please check.")
    if(!silent) message("%")
    if(!silent) message("% DONE!")
    if(!silent) message("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%")
    
    
    # # stop sinking
    # closeAllConnections()
    # 
    # # restore original warning mode
    # if(silent)
    #   options(warn = oldw)
    
    cleanup() #remove sinks and temporary maps
    
    
    # exception handling
  #   }, error = function(e) {
  # 
  #   # stop sinking
  #   closeAllConnections()
  # 
  #   # restore original warning mode
  #   if(silent)
  #     options(warn = oldw)
  # 
  #   # remove mask if there is any (and ignore error in case there is no mask)
  #   cmd_out <-tryCatch(suppressWarnings(execGRASS("r.mask", flags=c("r"), intern = T)), error=function(e){})
  # 
  #   if(keep_temp == FALSE)
  #     cmd_out <- execGRASS("g.remove", type="raster,vector", pattern=paste0("*_t,",stream,"_*,", basin_out, ",", points_processed, "_*"), flags=c("f", "b"), intern = T)
  # 
  #   stop(paste(e))
  # })
  # 
  
} # EOF
